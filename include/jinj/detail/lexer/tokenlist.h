/// @file tokenlist.h
/// @brief Token list container used by the JINJ lexer.
/// Dynamic container for lexer tokens.
/// @details This module defines a dynamic list structure for storing tokens
///          generated by the lexer. It provides efficient append and reserve
///          operations similar to C++'s std::vector
///
/// @addtogroup lexer
/// @{

#ifndef JINJ_DETAIL_LEXER_TOKENLIST_H
#define JINJ_DETAIL_LEXER_TOKENLIST_H

#include "result.h"
#include "token.h"

/// @struct JinjTokenList
/// @brief Dynamic array for storing lexer tokens.
/// @details Encapsulates a resizable buffer of tokens, automatically growing
///          its capacity when new tokens are appended.
typedef struct JinjTokenList {
    JinjToken* tokens; ///< Pointer to the allocated token buffer.
    usize len;         ///< Current number of tokens in the list.
    usize cap;         ///< Current capacity of the token buffer.
} JinjTokenList;

/// @internal
/// @brief Resize the token list buffer to a new capacity.
/// @param tl Pointer to the token list.
/// @param new_cap Desired new capacity.
/// @return Pointer to the resized token buffer, or `NULL` on allocation failure.
JinjToken* _jinj_token_list_resize(JinjTokenList* tl, usize new_cap);

/// @brief Initialize an empty token list.
/// @param tl Pointer to the token list to initialize.
void jinj_token_list_init(JinjTokenList* tl);

/// @brief Free resources held by a token list.
/// @param tl Pointer to the token list to deinitialize.
void jinj_token_list_deinit(JinjTokenList* tl);

/// @brief Append an existing token to the list.
/// @param tl Pointer to the token list.
/// @param tok Token to append.
/// @return Result indicating success or allocation failure.
JinjLexerResult jinj_token_list_append(JinjTokenList* tl, JinjToken tok);

/// @brief Append a new token created from type and location data.
/// @param tl Pointer to the token list.
/// @param type Token type.
/// @param line Line number in the source.
/// @param column Column number in the source.
/// @return Result indicating success or allocation failure.
JinjLexerResult jinj_token_list_append_new(JinjTokenList* tl, JinjTokenType type, int line, int column);

/// @brief Append a new token with an associated string value.
/// @param tl Pointer to the token list.
/// @param type Token type.
/// @param line Line number in the source.
/// @param column Column number in the source.
/// @param value Pointer to the string value.
/// @param value_len Length of the string value in bytes.
/// @return Result indicating success or allocation failure.
JinjLexerResult jinj_token_list_append_new_with_value(JinjTokenList* tl, JinjTokenType type, int line, int column,
                                                      const char* value, usize value_len);

/// @brief Extend the list with all tokens from another list.
/// @param tl Pointer to the destination token list.
/// @param other Pointer to the source token list.
/// @return Result indicating success or allocation failure.
JinjLexerResult jinj_token_list_extend(JinjTokenList* tl, JinjTokenList* other);

/// @brief Ensure the token list has capacity for at least `min_len` tokens.
/// @param tl Pointer to the token list.
/// @param min_len Minimum number of tokens to reserve space for.
/// @return Result indicating success or allocation failure.
/// @details Similar to Rust's `Vec::reserve`.
JinjLexerResult jinj_token_list_reserve(JinjTokenList* tl, usize min_len);

/// @brief Reserve exactly `min_len` capacity for tokens, reallocating if necessary.
/// @param tl Pointer to the token list.
/// @param min_len Exact number of tokens to reserve space for.
/// @return Result indicating success or allocation failure.
/// @details Similar to Rust's `Vec::reserve_exact`.
JinjLexerResult jinj_token_list_reserve_exact(JinjTokenList* tl, usize min_len);

#endif // JINJ_DETAIL_LEXER_TOKENLIST_H

/// @}

